# Bubble sort 冒泡排序

> ***冒泡排序的基本思想是：每次比较两个相邻的元素，如果它们的顺序错误就把它们交换***
> ***过来***

------

**注：数组索引0不存放数据！！**

> 例如我们需要将 `12 35 99 18 76` 这 5 个数进行*从大到小*的排序。既然是从大到小排序，
> *也就是说越小的越靠后*，你是不是觉得我在说废话，但是这句话很关键(∩_∩)。
> **首先比较第 1 位和第 2 位的大小，现在第 1 位是 12，第 2 位是 35。**发现 12 比 35 要小，因为我们希望越小越靠后嘛，*因此需要交换这两个数的位置*。交换之后这 5 个数的顺序是
> `35 12 99 18 76`。按照刚才的方法，*继续比较第 2 位和第 3 位的大小*，**第 2 位是 12，第 3 位是 99**。 12 比
> 99 要小，*因此需要交换这两个数的位置*。交换之后这 5 个数的顺序是 `35 99 12 18 76`。
> 根据刚才的规则，*继续比较第 3 位和第 4 位的大小，如果第 3 位比第 4 位小*，则交换位
> 置。交换之后这 5 个数的顺序是 `35 99 18 12 76`。
> *最后，比较第 4 位和第 5 位*。 4 次比较之后 5 个数的顺序是 35 99 18 76 12。
> 经过 4 次比较后我们*发现最小的一个数已经就位*（**已经在最后一位，请注意 12 这个数**
> **的移动过程**），是不是很神奇。现在再来回忆一下刚才比较的过程。***每次都是比较相邻的两***
> ***个数，如果后面的数比前面的数大，则交换这两个数的位置。一直比较下去直到最后两个数***
> ***比较完毕后，最小的数就在最后一个了***。就如同是一个气泡，一步一步往后“翻滚”，直到
> 最后一位。所以这个排序的方法有一个很好听的名字“***冒泡排序***”。

<img src="https://i.loli.net/2020/04/28/rUsJnkNcbOYjT4M.png" >

> 说到这里其实我们的排序只将 5 个数中最小的一个归位了。每将一个数归位我们将其称为“一趟”。下面我们将继续重复刚才的过程，将剩下的 4 个数一一归位。

> 好，现在开始“**第二趟**”，***目标是将第 2 小的数归位***。*首先还是先比较第 1 位和第 2 位*，
> 如果第 1 位比第 2 位小，则交换位置。交换之后这 5 个数的顺序是 `99 35 18 76 12`。接下来你
> 应该都会了，*依次比较第 2 位和第 3 位，第 3 位和第 4 位*。**注意此时已经不需要再比较第 4**
> **位和第 5 位**。**因为在第一趟结束后已经可以确定第 5 位上放的是最小的了**。第二趟结束之后
> 这 5 个数的顺序是 `99 35 76 18 12`。

> “第三趟”也是一样的。第三趟之后这 5 个数的顺序是 `99 76 35 18 12`。
> **现在到了最后一趟“第四趟”**。有的同学又要问了，*这不是已经排好了吗？还要继续？*
> *当然，这里纯属巧合，你若用别的数试一试可能就不是了。*你能找出这样的数据样例来吗？
> 请试一试。

> “冒泡排序”的***原理***是：*每一趟* **只能确定将一个数归位**。即**第一趟只能确定将末位上的**
> **数（即第 5 位）归位**，**第二趟只能将倒数第 2 位上的数（即第 4 位）归位**，**第三趟只能将倒**
> **数第 3 位上的数（即第 3 位）归位**，*而现在前面还有两个位置上的数没有归位*，因此我们仍
> 然需要进行“第四趟”。

> **“第四趟”** *只需要比较第 1 位和第 2 位的大小*。因为*后面三个位置上的数归位了*，现在
> *第 1 位是 99，第 2 位是 76*，**无需交换**。这 5 个数的顺序不变仍然是 `99 76 35 18 12`。*到此排*
> *序完美结束了*， *5 个数已经有 4 个数归位，那最后一个数也只能放在第 1 位了*。

------

> 最后我们*总结一下*：如果有 ***n*** 个数进行排序，只需将 ***n - 1*** 个数归位，也就是说*要进行*
> ***n - 1*** 趟操作。 而“***每一趟***”都***需要从第 1 位开始进行相邻两个数的比较***，***将较小的一个数放***
> ***在后面，比较完毕后向后挪一位继续比较下面两个相邻数的大小***，*重复此步骤*，*直到最后一*
> *个**尚未归位**的数*，*已经归位的数则无需再进行比较*（已经归位的数你还比较个啥，浪费表情）。

> 再来看我是如何实现的。

**注：数组索引0不存放数据！！**

```c
#include <stdio.h>
int main()
{
	int a[100], i, j, t, n;
	scanf("%d", &n); 				//输入一个数n，表示接下来有n个数
	for ( i = 1; i <= n; i ++) 		//循环读入n个数到数组a中
		scanf("%d", &a[i]);
	//冒泡排序的核心部分
	for ( i = 1; i <= n - 1; i ++) 	//n个数排序，只用进行n-1趟
	{
		for ( j = 1; j <= n - i; j ++) //从第1位开始比较直到最后一个尚未归位的数，想一想为什么到n-i就可以了。原书j=1因为a[0] 不存储任何值，但书中并为描述
        // 因为有 i 个数已经被排好了
		{
			if ( a[j] < a[j + 1]) //比较大小并交换
				{ t = a[j]; a[j] = a[j + 1]; a[j + 1] = t; }
		}
	}
	for ( i = 1; i <= n; i ++) 		//输出结果
		printf("%d ", a[i]);
	getchar();getchar();
	return 0;
}
```

**注：数组索引0不存放数据！！**

> 将上面代码稍加修改，就可以解决第 1 节遗留的问题，如下。

```c
#include <stdio.h>
struct student
{
	char name[21];
	char score;
};//这里创建了一个结构体用来存储姓名和分数
int main()
{
	struct student a[100],t;
	int i, j, n;
	scanf("%d", &n); 	//输入一个数n
	for ( i = 1; i <= n; i ++) 	//循环读入n个人名和分数
		scanf("%s %d", a[i].name, &a[i].score);
    //按分数从高到低进行排序
	for ( i = 1; i <= n -1; i ++)
	{
		for ( j = 1; j <= n - i; j ++)
		{
			if ( a[j].score < a[j + 1].score)	//对分数进行比较
				{ t = a[j]; a[j] = a[j + 1]; a[j + 1] = t; }
		}
	}
	for ( i = 1; i <= n; i ++)	//输出人名
		printf("%s\n", a[i].name);
	getchar();getchar();
	return 0;
}
```

> **冒泡排序**的**核心部分**是***双重嵌套循环***。 不难看出冒泡排序的**时间复杂度**是 $O(N^2)$。这是
> **一个非常高的时间复杂度**。冒泡排序早在 1956 年就有人开始研究，之后有很多人都尝试过
> 对冒泡排序进行改进，但结果却令人失望。如 Donald E. Knuth（中文名为高德纳， 1974 年
> 图灵奖获得者）所说：“冒泡排序除了它迷人的名字和导致了某些有趣的理论问题这一事实
> 之外，似乎没有什么值得推荐的。”你可能要问：那还有没有更好的排序算法呢？不要走开，
> 请看下节——*快速排序*。

> Tips: **关于优化冒泡排序**，在算法中可以设置一个标志变量`flag` 规定当 `flag` 为 1 时，说明本趟排序中发生元素交换的动作，因此还需进行下一趟比较。当 `flag` 为 0 时， 说明本趟排序中已经没有元素的交换，只有元素的比较，因此表明该序列已经按值有序，排序可以停止。

**注：数组索引0不存放数据！！**

```c
void bubblesort(keytype k[], int n) // 一个数组k和n个元素
{
    int i, j, tmp, flag = 1;
    for (i = 1; i <= n - 1 && flag == 1; i ++)
    {
        flag = 0;
        for (j = 1; j <= n - i; j ++)
        {
            if (k[j] > k[j + 1])
            {
                tmp = k[j + 1];
                k[j + 1] = k[j];
                k[j] = tmp;
                flag = 1; // 发生了数据交换，flag变为1
            }
        }
    }
}
```

