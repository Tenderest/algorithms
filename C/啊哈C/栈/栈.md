# Stack 栈

> 上一节中我们学习了**队列**，它是一种**先进先出**的数据结构。还有一种是**后进先出**的数据
> 结构，**它叫做栈**。栈**限定为只能在一端进行插入和删除操作**。*比如说有一个小桶，小桶的直*
> *径只能放一个小球，我们现在小桶内依次放入 2、 1、 3 号小球。假如你现在需要拿出 2 号小球，*
> *那就必须先将 3 号小球拿出，再拿出 1 号小球，最后才能将 2 号小球拿出来。在刚才取小球的*
> *过程中，我们最先放进去的小球最后才能拿出来，最后放进去的小球却可以最先拿出来。*

<img src="https://i.loli.net/2020/04/29/OpzX1ve9CMuEWcy.png" >

> 生活中也有很多这样的例子， *比如我们在吃桶装薯片的时候，要想吃掉最后一片，就必*
> *须把前面的全部吃完（貌似现在的桶装薯片为了减少分量，在桶里面增加了一个透明的抽*
> *屉）；再比如浏览网页的时候需要退回到之前的某个网页，我们需要一步步地点击后退键。*
> *还有手枪的弹夹，在装子弹的时候，最后装入的那发子弹，是被第一个打出去的*。**栈的实现**
> **也很简单，只需要一个一维数组和一个指向栈顶的变量 top 就可以了。我们通过 top 来对栈**
> **进行插入和删除操作。**

> 栈究竟有哪些作用呢？我们来看一个例子。“` xyzyx`”是一个**回文字符串**，**所谓回文字符**
> **串就是指正读反读均相同的字符序列**，如“席主席”、“记书记”、“ `aha`”和“ `ahaha`”均是回
> 文，*但“ `ahah`”不是回文*。**通过栈这个数据结构我们将很容易判断一个字符串是否为回文**。

> 首先我们需要读取这行字符串，并求出这个字符串的长度。

```c
char a[101];
int len;
gets(a);
len=strlen(a);
```

> 如果一个字符串是回文的话，那么**它必须是中间对称**的，我们需要求中点，即：

```c
mid = len / 2 - 1;
```

> 接下来就轮到栈出场了。

> 我们先将 `mid`之前的字符全部入栈。因为这里的栈是用来存储字符的，所以这里用来实
> 现栈的数组类型是字符数组即 `char s[101];`，初始化栈很简单， `top=0;`就可以了。入栈的操作
> 是 `top++; s[top]=x;` （假设需要入栈的字符暂存在字符变量 `x` 中），其实可以简写为 `s[++ top]=x;`。

> 现在我们就来将 `mid` 之前的字符依次全部入栈。

```c
for (i = 0; i <= mid; i ++) //原书中此处 i <= mid 少了 = 号
{
    s[++ top] = a[i];
}
```

> 接下来进入判断回文的*关键步骤*。 **将当前栈中的字符依次出栈**，看看是否能与 `mid` 之后
> 的字符**一一匹配**，**如果都能匹配则说明这个字符串是回文字符串**，**否则这个字符串就不是回**
> **文字符串**。

```c
	for(i = mid + 1; i <= len - 1; i ++)
	{
		if (a[i] != s[top])
		{
			break;
		}
		top --;
	}
	if(top == 0)
		printf("YES");
	else
		printf("NO");
```

> 最后如果 `top` 的值为 `0`，就说明**栈内所有的字符都被一一匹配了**，**那么这个字符串就是**
> **回文字符串**。完整的代码如下。

```c
#include <stdio.h>
#include <string.h>
int main()
{
	char a[101],s[101];
	int i, len, mid, next, top;
	gets(a);		//读入一行字符串
	len = strlen(a); 	//求字符串的长度
	mid = len / 2 - 1; 	//求字符串的中点
	top = 0;			//栈的初始化
	//将mid前的字符依次入栈
	for(i = 0; i <= mid; i ++)
		s[++ top] = a[i];
	//判断字符串的长度是奇数还是偶数，并找出需要进行字符匹配的起始下标
	if(len % 2 == 0)
		next = mid + 1;
	else
		next = mid + 2;
    //开始匹配
	for(i = next; i <= len - 1; i ++)
    {
		if(a[i] != s[top])
			break;
		top --;
	}
	//如果top的值为0，则说明栈内所有的字符都被一一匹配了
	if(top == 0)
		printf("YES");
	else
		printf("NO");
	getchar();getchar();
	return 0;
}
```

> *栈还可以用来进行验证括号的匹配*。*比如输入一行只包含“ ()[]{}”的字符串*，请判断
> 形如“ `([{}()])`”或者“ `{()[]{}}`”的**是否可以正确匹配**。显然上面两个例子都是可以正确匹
> 配的。“ ([)]”是不能匹配的。有兴趣的同学可以自己动手来试一试。
> 堆栈最早由 Alan M. Turing（艾伦·图灵）于 1946 年提出，当时是为了解决子程序的调
> 用和返回。艾伦·图灵这个大帅哥可是个大牛人，图灵奖就是以他的名字命名的。如果你对
> 他感兴趣不妨去读一读《艾伦·图灵传：如谜的解谜者》和《图灵的秘密》