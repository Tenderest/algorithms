# Bucket sort 简化版的桶排序

> 首先出场的是我们的主人公小哼，上面这个可爱的娃就是啦。期末考试完了老师要将同
> 学们的分数按照从高到低排序。小哼的班上只有 5 个同学，这 5 个同学分别考了 5 分、 3 分、
> 5 分、 2 分和 8 分，哎考得真是惨不忍睹（满分是 10 分）。接下来将分数进行从大到小排序，
> 排序后是 8 5 5 3 2。你有没有什么好方法编写一段程序，让计算机随机读入 5 个数然后将这
> 5 个数从大到小输出？

> 我们这里只需借助一个一维数组就可以解决这个问题。
> 首先我们需要申请一个大小为 11 的数组 `int a[11]`。 OK，现在你已经有了 11 个变量，编
> 号从 `a[0]`~`a[10]`。刚开始的时候，我们将 `a[0]`~`a[10]`都初始化为 `0`，*表示这些分数还都没有人*
> *得过*。例如 `a[0]`等于 0 就**表示目前还没有人得过 0 分**，同理 `a[1]`等于 0 就**表示目前还没有人**
> **得过 1 分**……`a[10]`等于 0 就**表示目前还没有人得过 10 分**

<img src="https://i.loli.net/2020/04/28/wOAFHD8ts4dIYRg.png" >

> 下面开始处理每一个人的分数， 第一个人的分数是 5 分，我们就将相对应的 `a[5]`的值在
> 原来的基础增加 1，即将 `a[5]`的值从` 0` 改为 `1`，表示 5 分出现过了一次。

<img src="https://i.loli.net/2020/04/28/UpwQzXfNulrEKJD.png" >

> ... ... ... 省略重复步骤
>
> 按照刚才的方法处理第四个和第五个人的分数。*最终结果*就是下面这个图啦。

<img src="https://i.loli.net/2020/04/28/QFoBN83HuhT54ZD.png" >

> 你发现没有， a[0]~a[10]中的数值其实就是 0 分到 10 分每个分数出现的次数。接下来，
> 我们只需要将出现过的分数打印出来就可以了，出现几次就打印几次，具体如下。
> a[0]为 0，表示“ 0”没有出现过，不打印。
> a[1]为 0，表示“ 1”没有出现过，不打印。
> a[2]为 1，表示“ 2”出现过 1 次，打印 2。
> a[3]为 1，表示“ 3”出现过 1 次，打印 3。
> a[4]为 0，表示“ 4”没有出现过，不打印。
> a[5]为 2，表示“ 5”出现过 2 次，打印 5 5。
> a[6]为 0，表示“ 6”没有出现过，不打印。
> a[7]为 0，表示“ 7”没有出现过，不打印。
> a[8]为 1，表示“ 8”出现过 1 次，打印 8。
> a[9]为 0，表示“ 9”没有出现过，不打印。
> a[10]为 0，表示“ 10”没有出现过，不打印。
> 最终屏幕输出“ 2 3 5 5 8”，完整的代码如下。

```c
#include <stdio.h>
int main()
{
	int a[11], i, j, t;
	for ( i = 0; i <= 10; i ++)
	a[i] = 0; 				//初始化为0
	for ( i = 1; i <= 5; i ++) 		//循环读入5个数
	{
    	scanf("%d", &t); 	//把每一个数读到变量t中
		a[t] ++; 			//进行计数
	}
	for ( i = 0; i <= 10; i ++) 		//依次判断a[0]~a[10]
		for ( j = 1; j <= a[i]; j ++) 	//出现了几次就打印几次
			printf("%d ", i);
	getchar();getchar();
	//这里的getchar();用来暂停程序，以便查看程序输出的内容
	//也可以用system("pause");等来代替
	return 0;
}
```

> 仔细观察的同学会发现，刚才实现的是从小到大排序。但是我们要求是从大到小排序，
> 这该怎么办呢？还是先自己想一想再往下看哦。
> 其实很简单。 只需要将 `for(i=0;i<=10;i++)改为 for(i=10;i>=0;i--)`就 OK 啦，快去试一试吧。
> 这种排序方法我们暂且叫它“*桶排序*”。因为***其实真正的桶排序要比这个复杂一些***，以
> 后再详细讨论，目前此算法已经能够满足我们的需求了。
> 这个算法就好比有 11 个桶，编号从 0~10。每出现一个数，就在对应编号的桶中放一个
> 小旗子，最后只要数数每个桶中有几个小旗子就 OK 了。例如 2 号桶中有 1 个小旗子，表示
> 2 出现了一次； 3 号桶中有 1 个小旗子，表示 3 出现了一次； 5 号桶中有 2 个小旗子，表示 5
> 出现了两次； 8 号桶中有 1 个小旗子，表示 8 出现了一次。

<img src="https://i.loli.net/2020/04/28/wFH3fJ8dp9ZKxz2.png" >

> 如果需要对数据范围在 0~1000 之间的整数进行排序，*我们需要 1001 个桶，来表示 0~1000*
> *之间每一个数出现的次数，这一点一定要注意*。另外，**此处的每一个桶的作用其实就是“标**
> **记”每个数出现的次数，**

```c
#include <stdio.h>
int main()
{
	int book[1001], i, j, t, n;
	for ( i = 0; i <= 1000; i ++)
		book[i] = 0;
	scanf("%d", &n);				//输入一个数n，表示接下来有n个数
	for ( i = 1; i <= n; i ++)			//循环读入n个数，并进行桶排序
	{
		scanf("%d", &t);	 		//把每一个数读到变量t中
		book[t] ++; 				//进行计数，对编号为t的桶放一个小旗子
	}
	for ( i = 1000; i >= 0; i --) 		//依次判断编号1000~0的桶
		for ( j = 1; j <= book[i]; j ++) //出现了几次就将桶的编号打印几次
			printf("%d ", i);
	getchar();getchar();
	return 0;
}
```

> 最后来说下时间复杂度的问题。代码中第 6 行的循环一共循环了 m 次（ *m 为桶的个数*），
> 第 9 行的代码循环了 n 次（ *n 为待排序数的个数*），第 14 行和第 15 行一共循环了 m+n 次。
> 所以整个排序算法一共执行了 `m+n+m+n` 次。我们用大写字母 `O` 来表示***时间复杂度***，因此该算法的时间复杂度是 `O(m+n+m+n)`即 `O(2*(m+n))`。 我们在说***时间复杂度的时候可以忽略较小的常数***，最终桶排序的时间复杂度为 `O(m+n)`。还有一点，在表示时间复杂度的时候， n 和 m
> *通常用大写字母*即 O(M+N)。

这是一个非常快的排序算法。桶排序从 1956 年就开始被使用，该算法的基本思想是由
`E.J.Issac` 和 `R.C.Singleton` 提出来的。之前我说过，***其实这并不是真正的桶排序算法***，真正的
桶排序算法要比这个更加复杂。但是考虑到此处是算法讲解的第一篇，我想还是越简单易懂
越好，真正的桶排序留在以后再聊吧。
