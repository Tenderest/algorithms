# Linked list 链表

## [指针回顾](#pointer)

## [链表](#linkedlist)

## [数组模拟链表](#array_linked)

> 在存储一大波数的时候，我们通常使用的是数组，但有时候数组显得不够灵活，比如下
> 面这个例子。

>有一串已经从小到大排好序的数 `2 3 5 8 9 10 18 26 32`。现需要往这串数中**插入 `6`** **使其得**
>**到的新序列仍符合从小到大排列**。**如我们使用数组来实现**这一操作，**则需要将 8 和 8 后面的**
>**数都依次往后挪一位**，如下：

<img src="https://i.loli.net/2020/04/29/LNwpATIK2CeXbVW.png" >

> 这样操作显然很耽误时间，如果使用链表则会快很多。**那什么是链表呢？请看下图**。

<img src="https://i.loli.net/2020/04/29/3Q8FZDIlMdzKSPA.png" >

> 此时如果需要在 8 前面插入一个 6，*就只需像下图这样更改一下就可以了，而无需再将*
> *8 及后面的数都依次往后挪一位。是不是很节省时间呢？*

<img src="https://i.loli.net/2020/04/29/rcvukFOzalBVtqA.png" >

## 指针回顾{#pointer}

> *那么如何实现链表呢*？在 **C 语言中可以使用指针和动态分配内存函数 `malloc` 来实现**。
> 指针？天啊！如果你在学习 C 语言的时候没有搞懂指针，或者还不知道指针是啥，不要紧，
> 我们现在就回顾一下指针。指针其实超级简单。如果你已经对指针和 `malloc` 了如指掌则可以
> 跳过下面这一小段，继续往后看。
> 先看下面两行语句。

```c
int a;
int * p;
```

> 第一行我们很熟悉了，就是定义一个**整型变量 `a`**。第二行你会发现在 **`p` 前面多了一个`*`**
> 号，这就表示定义了一个**整型指针变量 `p`**。**即定义一个指针，只需在变量前面加一个*号就**
> **OK 啦**。

> 接下来，**指针有什么作用呢**？答案是：**存储一个地址**。**确切地说是*存储一个内存空间的***
> ***地址*，比如说整型变量 `a` 的地址**。**严格地说这里的指针 `p` 也只能存储“*一个存放整数的内存***
> ***空间*”的地址，因为在定义的时候我们已经限制了这一点（*即定义的时候*`*p` *的前面是 `int`* ）**。
> 当然你也可以定义一个只能用来存储“*一个存放浮点数的内存空间”的地址*，例如：

```c
double * p;
```

> 简单地说， **指针就是用来存储地址的**。你可能要问：不就是存储地址嘛，地址不都一样
> 吗，**为什么还要分不同类型的指针呢？**不要着急，待会后面再解释。接下来需要解决的一个
> 问题：**整型指针 `p` 如何才能存储整型变量 `a` 的地址呢？**很简单，如下：

```c
p = &a;
```

> `&`这个符号很熟悉吧， 就是经常在 `scanf` 函数中用到的`&`。 `&`叫**取地址符**。这样整型指针`p` 就获得了（存储了）整型变量 `a` 的地址，**我们可以形象地理解整型指针 `p` 指向了整型变量`a`**。 p 指向了 a 之后，有什么用呢？**用处就是我们可以用指针 `p` 来操作变量 `a` 了**。比如我们**可以通过操作指针 `p` 来输出变量 `a` 的值**，如下：

```c
#include <stdio.h>
int main()
{
	int a = 10;
	int * p; //定义个指针p
	p = &a; //指针p获取变量a的地址
	printf("%d", *p); //输出指针p所指向的内存中的值
	getchar();getchar();
	return 0;
}
// 运行结果是 10
```

> 这里 `printf` 语句里面`*p` 中的`*`号叫做**间接运算符**，**作用是取得指针 `p` 所指向的内存中的值**。在 C 语言中`*`号有三个用途，分别是：
> 1. **乘号**，用做乘法运算，例如 `5*6`。
> 2. **申明一个指针**，在定义指针变量时使用，例如 `int *p;`。
> 3. **间接运算符**，取得指针所指向的内存中的值，例如 `printf("%d",*p);`。

> 到目前为止，你可能还是觉得指针没啥子实际作用，好好的变量 `a` 想输出是的话直接 `printf("%d",a);` 不完了，没事搞个什么指针啊，多此一举。嗯，到目前为止貌似是这样的
> O(∩ _∩ )O 哈哈~~不要着急，真枪实弹地来了

> 回想一下，我们想在程序中存储一个整数 `10`，除了使用 `int a;`这种方式在内存中申请一块区域来存储，还有另外一种动态存储方法。

```c
malloc(4);
```

> `malloc` 函数的作用就是从内存中申请分配指定字节大小的内存空间。上面这行代码就申请了 4 个字节。如果你不知道 `int` 类型是 4 个字节的，还可以使用 `sizeof(int)`获取 `int` 类型所占用的字节数，如下：

```c
malloc(sizeof(int));
```

> 现在你已经成功地从内存中申请了 4 个字节的空间来准备存放一个整数，**可是如何来对这个空间进行操作呢**？这里我们就**需要用一个指针来指向这个空间，即存储这个空间的首地址**

```c
int * p;
p = (int *) malloc(sizeof(int));
```

> 需要注意， `malloc` 函数的返回类型是 `void *` 类型。 `void *` **表示未确定类型的指针**。在 `C`和 `C++`中， `void *` 类型**可以强制转换为任何其他类型的指针**。**上面代码中我们将其强制转化为整型指针**，以便告诉计算机这里的 4 个字节作为一个整体用来存放整数。还记得我们之前遗留了一个问题：**指针就是用来存储内存地址的，为什么要分不同类型的指针呢**？因为**指针变量存储的是一个内存空间的首地址**（**第一个字节的地址**），**但是这个空间占用了多少个字节，用来存储什么类型的数，则是由指针的类型来标明的**。**这样系统才知道应该取多少个连续内存作为一个数据**。

> OK，现在我们可以通过指针 `p` 对刚才申请的 4 个字节的空间进行操作了，例如我们向
> 这个空间中存入整数 10，如下：

```c
*p = 10;
```

> 完整代码如下，注意当在程序中使用 `malloc` 函数时需要用到 `stdlib.h` 头文件。

```c
#include <stdio.h>
#include <stdlib.h>
int main()
{
	int * p; //定义一个指针p
	p = (int *) malloc(sizeof(int)); //指针p获取动态分配的内存空间地址
	*p = 10; //向指针p所指向的内存空间中存入10
	printf("%d", *p); //输出指针p所指向的内存中的值
	getchar();getchar();
	return 0;
}
// 运行结果是 10
```

## 链表{#linkedlist}

> 到这里你可能要问：**为什么要用这么复杂的办法来存储数据呢**？因为**之前的方法，我们**
> **必须预先准确地知道所需变量的个数，也就是说我们必须定义出所有的变量**。**比如我们定义**
> **了 100 个整型变量，那么程序就只能存储 100 个整数，如果现在的实际情况是需要存储 101**
> **个，那必须修改程序才可以**。如果有一天你写的软件已经发布或者交付使用，却发现要存储
> 1000 个数才行，那就不得不再次修改程序，重新编译程序，发布一个新版本来代替原来的。
> 而有了 `malloc` 函数我们**便可以在程序运行的过程中根据实际情况来申请空间**。

> 啰嗦了半天，总算**介绍完了什么是指针以及如何动态申请空间**。注意，**本节接下来的代**
> **码对于还没有理解指针的朋友来说可能不太容易，不要紧，如果你痛恨指针，大可直接跳过**
> **下面的内容直接进入下一节**。**下一节中我将介绍链表的另外一种实现方式——数组模拟链表**。
> 首先我们来看一下，**链表中的每一个结点应该如何存储**

<img src="https://i.loli.net/2020/04/29/wAOoZB4LcmXYpkD.png" >

> **每一个结点都由两个部分组成**。**左边的部分用来存放具体的数值**，那么*用一个整型变量*
> *就可以*；**右边的部分需要存储下一个结点的地址**，*可以用指针来实现*（**也称为后继指针**）。
> 这里我们**定义一个结构体类型来存储这个结点**，如下。

```c
struct node
{
    int data;
    struct node * next;
};
```

<img src="https://i.loli.net/2020/04/29/LYG7HqsoDA8ZhvU.png" >

> 上面代码中，我们定义了一个叫做 `node` 的**结构体类型**，这个结构体类型*有两个成员*。第一个成员是整型`data`，**用来存储具体的数值**；第二个成员是一个**指针**，**用来存储下一个结点的地址**。**因为下一个结点的类型也是** `struct node`，所以**这个指针的类型也必须**是 `struct node *`类型的指针。

> **如何建立链表呢**？首先我们需要一个**头指针 `head` 指向链表的最开始**。**当链表还没有建立的时候头指针 `head` 为空（也可以理解为指向空结点）**。

```c
struct node * head;
head = NULL;//头指针初始为空
```

> 现在我们来**创建第一个结点**，并用**临时指针** `p` **指向这个结点**。

```c
struct node * p;
//动态申请一个空间，用来存放一个结点，并用临时指针p指向这个结点
p = (struct node *) malloc (sizeof(struct node));
```

> 接下来**分别设置新创建的这个结点的左半部分和右半部分**。

```c
scanf("%d", &a);
p->data = a;//将数据存储到当前结点的data域中
p->next = NULL;//设置当前结点的后继指针指向空，也就是当前结点的下一个结点为空
```

<img src="https://i.loli.net/2020/04/29/LYAjI73emHrx9PD.png" >

> 上面的代码中我们发现了一个很奇怪的符号“ `->`” 。 `->`叫做**结构体指针运算符**，**也是用来访问结构体内部成员的**。**因为此处 `p` 是一个指针**，**所以不能使用`.`号访问内部成员，而要**使用`->`**。

> 下面来设置**头指针**并设置**新创建结点的`*next` 指向空**。**头指针的作用是方便以后从头遍历整个链表**。

```c
if(head==NULL)
	head = p;//如果这是第一个创建的结点，则将头指针指向这个结点
else
	q->next = p;//如果不是第一个创建的结点，则将上一个结点的后继指针指向当前结点
```

> 如果这是第一个创建的结点，则将头指针指向这个结点。

<img src="https://i.loli.net/2020/04/29/s5txQWMy73XlCqL.png" >

> 如果不是第一个创建的结点，**则将上一个结点的后继指针指向当前结点**。

<img src="https://i.loli.net/2020/04/29/YGRadWfghQo63Di.png" >

> 最后要将指针 `q` **也指向当前结点**，**因为待会儿临时指针 `p` 将会指向新创建的结点**。

```c
q = p;//指针q也指向当前结点
```

> 完整代码如下。

```c
#include <stdio.h>
#include <stdlib.h>
//这里创建一个结构体用来表示链表的结点类型
struct node
{
	int data;
	struct node * next;
};
int main()
{
	struct node * head, * p, * q, * t;
	int i, n, a;
	scanf("%d", &n);
	head = NULL;//头指针初始为空
	for ( i = 1; i <= n; i ++)//循环读入n个数
	{
		scanf("%d", &a);
		//动态申请一个空间，用来存放一个结点，并用临时指针p指向这个结点
		p = (struct node *) malloc (sizeof(struct node));
		p->data = a;//将数据存储到当前结点的data域中
		p->next = NULL;//设置当前结点的后继指针指向空，也就是当前结点的下一个结点为空
		if ( head == NULL )
		    head = p;//如果这是第一个创建的结点，则将头指针指向这个结点
		else
			q->next = p;//如果不是第一个创建的结点，则将上一个结点的后继指针指向当前结点
		q = p;//指针q也指向当前结点
	}
	//输出链表中的所有数
	t = head;
	while ( t != NULL )
	{
	    printf("%d ", t->data);
		t = t->next;//继续下一个结点
	}
	getchar();getchar();
	return 0;
}
// 可以输入以下数据进行验证。
// 9
// 2 3 5 8 9 10 18 26 32
// 运行结果是：
// 2 3 5 8 9 10 18 26 32
```

> 需要说明的一点是： 上面这段代码没有释放动态申请的空间，*虽然没有错误，但是这样*
> *会很不安全*，有兴趣的朋友可以去了解一下 `free` 命令。

> 接下来需要往链表中插入 6，操作如下。

<img src="https://i.loli.net/2020/04/29/vfQP8eoxHt2JikS.png" >

> 首先用一个**临时指针 `t`** 从链表的**头部开始遍历**。

```c
t = head;//从链表头部开始遍历
```

> 等到指针 `t` 的***下一个*结点的值比 6 大的时候**，**将 6 插入到中间**。**即 `t->next->data` 大于 6**
> **时进行插入**，代码如下。

```c
scanf("%d", &a);//读入待插入的数
while(t != NULL)//当没有到达链表尾部的时候循环
{
	if (t->next->data > a)//如果当前结点下一个结点的值大于待插入数，将数插入到中间
    {
		p = (struct node *) malloc(sizeof(struct node));//动态申请一个空间，用来存放新增结点
		p->data = a;
		p->next = t->next;//新增结点的后继指针指向当前结点的后继指针所指向的结点
		t->next = p;//当前结点的后继指针指向新增结点
		break;//插入完毕退出循环
	}
	t = t->next;//继续下一个结点
}
```

> 完整代码如下。

```c
#include <stdio.h>
#include <stdlib.h>
//这里创建一个结构体用来表示链表的结点类型
struct node
{
	int data;
	struct node * next;
};
int main()
{
	struct node * head, * p, * q, * t;
	int i, n, a;
	scanf("%d", &n);
	head = NULL;//头指针初始为空
	for ( i =1 ; i <= n; i ++)//循环读入n个数
	{
		scanf("%d", &a);
		//动态申请一个空间，用来存放一个结点，并用临时指针p指向这个结点
		p = (struct node *) malloc(sizeof(struct node));
		p->data = a;//将数据存储到当前结点的data域中
		p->next = NULL;//设置当前结点的后继指针指向空，也就是当前结点的下一个结点为空
	    if ( head == NULL )
			head = p;//如果这是第一个创建的结点，则将头指针指向这个结点
		else
			q->next = p;//如果不是第一个创建的结点，则将上一个结点的后继指针指向当前结点
	    q = p;//指针q也指向当前结点
	}
	scanf("%d", &a);//读入待插入的数
	t = head;//从链表头部开始遍历
	while ( t != NULL )//当没有到达链表尾部的时候循环
	{
		if ( t->next->data > a)//如果当前结点下一个结点的值大于待插入数，将数插入到中间
		{
			p = (struct node *) malloc(sizeof(struct node));//动态申请一个空间，用来存放新增结点
			p->data = a;
			p->next = t->next;//新增结点的后继指针指向当前结点的后继指针所指向的结点
			t->next = p;//当前结点的后继指针指向新增结点
			break;//插入完毕退出循环
		}
	t = t->next;//继续下一个结点
	}
	//输出链表中的所有数
	t = head;
    while ( t != NULL )
	{
		printf("%d ", t->data);
		t = t->next;//继续下一个结点
	}
	getchar();getchar();
	return 0;
}
// 可以输入以下数据进行验证。
// 9
// 2 3 5 8 9 10 18 26 32
// 6
// 运行结果是：
// 2 3 5 6 8 9 10 18 26 32
```

# 模拟链表{#array_linked}

> 如果你觉得上一节的代码简直是天书，或者你压根就很讨厌指针这些东西，没关系！链
> 表还有另外一种使用数组来实现的方式，叫做模拟链表，我们一起来看看。

> 链表中的*每一个结点只有两个部分*。我们可以**用一个数组 data 来存储每序列中的每一个**
> **数**。**那每一个数右边的数是谁，这一点该怎么解决呢**？**上一节中是使用指针来解决的，这里**
> **我们只需再用一个数组 right 来存放序列中每一个数右边的数是谁就可以了**，具体怎么做呢？

<img src="https://i.loli.net/2020/04/29/uqMpD2YBI5UtT1y.png" >

> 上图的两个数组中，**第一个整型数组 `data`** 是用来**存放序列中具体数字的**，**另外一个整型**
> **数组 `right`** 是**用来存放当前序列**中**每一个元素右边的元素在数组 `data` 中位置**的。例如 **`right[1]`**
> **的值为 `2`，就表示当前序列中 `1` 号元素*右边的元素*存放在 `data[2]`中**；如果是 `0`，**例如 `right[9]`**
> **的值为 `0`，就表示当前序列中 `9` 号元素的*右边没有元素***。

> **现在需要在 `8` 前面插入一个 `6`**，**只需将 `6` 直接存放在数组 `data` 的末尾即 `data[10]=6`**。接下来**只需要将`right[3]`改为`10`**， **表示新序列中`3`号元素*右边的元素*存放在`data[10]`中**。 **再将 `right[10]`改为 `4`**，**表示新序列中 `10` 号元素*右边的元素*存放在 `data[4]`中**。这样我们通过 `right` 数组就**可以从头到尾遍历整个序列了（序列的每个元素的值存放在对应的数组 `data` 中）**，如下。

<img src="https://i.loli.net/2020/04/29/A7hbXkLvJaj3fcm.png" >

> 完整的代码实现如下。

```c
#include <stdio.h>
int main()
{
	int data[101], right[101];
    int i, n, t, len;
	//读入已有的数
	scanf("%d", &n);
	for ( i = 1; i <= n; i ++)
		scanf("%d", &data[i]);
	len = n;
	//初始化数组right
	for ( i = 1; i <= n; i ++)
	{
		if ( i != n)
			right[i] = i + 1;
		else
			right[i] = 0;
	}
	//直接在数组data的末尾增加一个数
	len ++;
	scanf("%d", &data[len]);
	//从链表的头部开始遍历
	t = 1;
    while ( t != 0 )
	{
		if ( data[ right[t] ] > data[len])//如果当前结点下一个结点的值大于待插入数，将数插入到中间
		{
			right[len] = right[t];//新插入数的下一个结点标号等于当前结点的下一个结点编号
			right[t] = len;//当前结点的下一个结点编号就是新插入数的编号
			break;//插入完成跳出循环
		}
		t = right[t];
	}
	//输出链表中所有的数
	t = 1;
	while ( t != 0 )
	{
		printf("%d ", data[t]);
		t = right[t];
	}
    getchar();
	getchar();
	return 0;
}
// 可以输入以下数据进行验证。
// 9
// 2 3 5 8 9 10 18 26 32
// 6
// 运行结果是：
// 2 3 5 6 8 9 10 18 26 32
// 使用模拟链表也可以实现双向链表和循环链表，大家可以自己来试一试。
```

